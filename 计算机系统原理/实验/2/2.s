   0x00400dbc <+0>:     addiu   sp,sp,-64       #开辟16*4的栈 sp=0x7ffff0f0:0x0041b190
   0x00400dc0 <+4>:     sw      ra,60(sp)       #*60(sp)=ra 60(sp)将ra存到栈中最底部
   0x00400dc4 <+8>:     sw      s8,56(sp)       #*56(sp)=s8 记录帧指针位置到56(sp)
   0x00400dc8 <+12>:    move    s8,sp           #s8=sp 帧指针s8置栈顶（sp处）
   0x00400dcc <+16>:    lui     gp,0x42         #gp=0x00420000(之前=0x0041b190)
   0x00400dd0 <+20>:    addiu   gp,gp,-20080    #gp=0x0041b190
   0x00400dd4 <+24>:    sw      gp,16(sp)       #*16(sp)=gp
   0x00400dd8 <+28>:    sw      a0,64(s8)       #*64(s8)=a0 a0存到64(s8) //a0=<input_strings+80>
   0x00400ddc <+32>:    addiu   v0,s8,28        #v0=s8+28
   0x00400de0 <+36>:    lw      a0,64(s8)       #a0=*64(s8) a0加载为64(s8)//傻不拉几的瞎捣鼓
   0x00400de4 <+40>:    move    a1,v0           #a1=v0
   0x00400de8 <+44>:    jal     0x401ba8 <read_six_numbers>#跳转，这一步将sp+28~sp+48更新为输入six_numbers的内容
   0x00400dec <+48>:    nop
   0x00400df0 <+52>:    lw      gp,16(s8)       #gp=*16(s8)
   0x00400df4 <+56>:    lw      v1,28(s8)       #v1=*28(s8),就是等于输入的第一个数
   0x00400df8 <+60>:    li      v0,1            #v0=1
   0x00400dfc <+64>:    beq     v1,v0,0x400e10 <phase_2+84> #输入第一个数字等于1，则该炸弹通过
   0x00400e00 <+68>:    nop
   0x00400e04 <+72>:    jal     0x4021f0 <explode_bomb>
   0x00400e08 <+76>:    nop
   0x00400e0c <+80>:    lw      gp,16(s8)
   0x00400e10 <+84>:    li      v0,1            #v0=1
   0x00400e14 <+88>:    sw      v0,24(s8)       #*24(s8)=v0=1 
   0x00400e18 <+92>:    b       0x400ea8 <phase_2+236> #无条件跳转
   0x00400e1c <+96>:    nop
   0x00400e20 <+100>:   lw      v0,24(s8)       #v0=*24(sp)
   0x00400e24 <+104>:   nop
   0x00400e28 <+108>:   addiu   v0,v0,-1        #v0=v0-1
   0x00400e2c <+112>:   sll     v0,v0,0x2       #v0<<2 v0左移两位,相当于v0=v0*4
   0x00400e30 <+116>:   addiu   v1,s8,24        #v1=s8+24  猜测s8+24中存储了该循环的i
   0x00400e34 <+120>:   addu    v0,v1,v0        #v0=v1+v0
   0x00400e38 <+124>:   lw      a0,4(v0)        #a0=*4(v0) 相当于让a0等于v0指向的地址下一位所存的数，4个存一个嘛
   0x00400e3c <+128>:   li      v1,12           #v1=12
   0x00400e40 <+132>:   lw      v0,24(s8)       #v0=*24(s8)
   0x00400e44 <+136>:   nop
   0x00400e48 <+140>:   subu    v0,v1,v0        #v0=v1-v0=12-v0
   0x00400e4c <+144>:   lw      v1,-32660(gp)   #v1=*-32660(gp)=0x413264<ID_num>  //发现<ID_num>后移-20可以找到我们输入的ID,有意思，详见图ID_num前移
   0x00400e50 <+148>:   sll     v0,v0,0x2       #v0<<2
   0x00400e54 <+152>:   addu    v0,v1,v0        #v0=v1+v0
   0x00400e58 <+156>:   lw      v0,0(v0)        #v0=*0(v0)    #发现（第一次）恰好找到了输入的ID最后一位的字符转化后的数字！我们可以推测，读取ID时使用了某种特殊的规则，让解析出来的字符存储到了该位置
   0x00400e5c <+160>:   nop
   0x00400e60 <+164>:   mult    a0,v0           #hilo=a0*v0
   0x00400e64 <+168>:   mflo    a0              #乘法的低32位放到a0中，就是上面的运算结果
   0x00400e68 <+172>:   lw      v0,24(s8)       #v0=*24(s8)
   0x00400e6c <+176>:   nop
   0x00400e70 <+180>:   sll     v0,v0,0x2       #v0<<2 v0=v0*4
   0x00400e74 <+184>:   addiu   v1,s8,24        #v1=s8+24
   0x00400e78 <+188>:   addu    v0,v1,v0        #v0=v1+v0  访问输入数字中的某一个
   0x00400e7c <+192>:   lw      v0,4(v0)        #v0=*4(v0) 访问后一位的数字 //访问sm[i+1]
   0x00400e80 <+196>:   nop
   0x00400e84 <+200>:   beq     a0,v0,0x400e98 <phase_2+220>       #a0=v0则跳转 分析其含义为（第一次循环）：查看输入的ID的最后一位与输入的六位数字的第一位的乘积是否与第二位相等 s_n[i+1]==sn[i]*ID_n[len+1-i]
   0x00400e88 <+204>:   nop
   0x00400e8c <+208>:   jal     0x4021f0 <explode_bomb>
   0x00400e90 <+212>:   nop
   0x00400e94 <+216>:   lw      gp,16(s8)
   0x00400e98 <+220>:   lw      v0,24(s8)
   0x00400e9c <+224>:   nop
   0x00400ea0 <+228>:   addiu   v0,v0,1     #v0自增
   0x00400ea4 <+232>:   sw      v0,24(s8)   #存入24(s8)
@  0x00400ea8 <+236>:   lw      v0,24(s8)   #v0=*24(s8)
   0x00400eac <+240>:   nop
   0x00400eb0 <+244>:   slti    v0,v0,6     #v0=(v0<6)
   0x00400eb4 <+248>:   bnez    v0,0x400e20 <phase_2+100> #v0!=0则跳转
   0x00400eb8 <+252>:   nop
   0x00400ebc <+256>:   move    sp,s8
   0x00400ec0 <+260>:   lw      ra,60(sp)
   0x00400ec4 <+264>:   lw      s8,56(sp)
   0x00400ec8 <+268>:   addiu   sp,sp,64
   0x00400ecc <+272>:   jr      ra
   0x00400ed0 <+276>:   nop